Attribute VB_Name = "modTaskManager"
Option Explicit

'API's Function Declarations
Private Declare Function IsWindow Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As Any, ByVal lpWindowName As String) As Long

'API Constants
Public Const GWL_STYLE = -16
Public Const WS_DISABLED = &H8000000
Public Const WM_CANCELMODE = &H1F
Public Const WM_CLOSE = &H10

Public Function IsTaskRunning(sWindowName As String) As Boolean
    Dim hWnd As Long, hWndOffline As Long
    
    On Error GoTo IsTaskRunning_Eh
    'get handle of the application
    'if handle is 0 the application is currently not running
    hWnd = FindWindow(0&, sWindowName)
    If hWnd = 0 Then
        IsTaskRunning = False
        Exit Function
    Else
        IsTaskRunning = True
    End If
    
IsTaskRunning_Exit:
    
    Exit Function
    
IsTaskRunning_Eh:
    Call ShowError(sWindowName, "IsTaskRunning")
End Function

Public Function EndTask(sWindowName As String) As Integer
    Dim X As Long, ReturnVal As Long, TargetHwnd As Long
    'find handle of the application
    TargetHwnd = FindWindow(0&, sWindowName)
    If TargetHwnd = 0 Then
        Exit Function
        If IsWindow(TargetHwnd) = False Then GoTo EndTaskFail
    Else
        'close application
        If Not (GetWindowLong(TargetHwnd, GWL_STYLE) And WS_DISABLED) Then
            X = PostMessage(TargetHwnd, WM_CLOSE, 0, 0&)
            DoEvents
        End If
    End If
    
    GoTo EndTaskSucceed
    
EndTaskFail:
    
    ReturnVal = False
    MsgBox "EndTask: cannot terminate " & sWindowName & " task"
    GoTo EndTaskEndSub
EndTaskSucceed:
    ReturnVal = True
EndTaskEndSub:
    EndTask% = ReturnVal
End Function

Public Sub CloseTask(TargetAppHwnd As Long, bWaitForReturn As Boolean)
    Dim lRet As Long
    
    If TargetAppHwnd <> 0 Then
        If IsWindow(TargetAppHwnd) = True Then
            If Not (GetWindowLong(TargetAppHwnd, GWL_STYLE) And WS_DISABLED) Then 'Window not disabled.
                If bWaitForReturn = True Then
                    lRet = SendMessage(TargetAppHwnd, WM_CLOSE, 0&, 0&) 'Wait for return
                Else
                    lRet = PostMessage(TargetAppHwnd, WM_CLOSE, 0&, 0&) 'Don't wait for return
                    DoEvents 'Causes processing of PostMEssage
                End If
            End If
        End If
    End If
End Sub

Public Function ShowError(sText As String, sProcName As String)   'this function displays an error that occurred
    Dim sMsg As String
    sMsg = "Error # " & Str(Err.Number) & " was generated by " & Err.Source & vbCrLf & Err.Description
    MsgBox sMsg, vbCritical, sText & Space(1) & sProcName
    Exit Function
End Function
